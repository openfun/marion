{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Marion is a documents factory backend to generate PDF files using a REST API and HTML/CSS templates. Key concepts \u00b6 Marion is a Django application that can be integrated to your Django project or deployed to production as a standalone service. To generate PDF files with styles, first, you will have to write your own document issuer and related HTML/CSS templates in a Django application package. Once your issuer has been installed and configured, you can create a document request using the backend API with your favorite HTTP client (we \u2764\ufe0f http , but curl is perfectly fine \ud83d\ude09): # Create a new document using the dummy issuer $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' As you may have noticed, you should provide two parameters for this request: the document issuer for this request (as a python module path), and, a context_query that will be used by the issuer to resolve the context that will be injected in your HTML/CSS templates to generate a document; think of a context as a Django template context . If you get lucky, your document has been cooked. It is available for download in the configured MEDIA_ROOT of the Django project Marion has been integrated to. You will find the link to the PDF document in the newly created document request (see the document_url field): { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : { \"fullname\" : \"John Doe\" , \"identifier\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" }, \"context_query\" : { \"fullname\" : \"John Doe\" }, \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" } Key takeways \u00b6 Issuer : this keyword designates a particular type of document with its own templates and logic to fetch a context that will be used to create it. Document request : a database entry tracking the context (query) used to generate a document and its download link. Context query : parameters that will be used by an issuer to fetch a context that will be used to compile a document template. Context : all variables that will be used to render document templates ( e.g. a Django context).","title":"Introduction"},{"location":"#introduction","text":"Marion is a documents factory backend to generate PDF files using a REST API and HTML/CSS templates.","title":"Introduction"},{"location":"#key_concepts","text":"Marion is a Django application that can be integrated to your Django project or deployed to production as a standalone service. To generate PDF files with styles, first, you will have to write your own document issuer and related HTML/CSS templates in a Django application package. Once your issuer has been installed and configured, you can create a document request using the backend API with your favorite HTTP client (we \u2764\ufe0f http , but curl is perfectly fine \ud83d\ude09): # Create a new document using the dummy issuer $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' As you may have noticed, you should provide two parameters for this request: the document issuer for this request (as a python module path), and, a context_query that will be used by the issuer to resolve the context that will be injected in your HTML/CSS templates to generate a document; think of a context as a Django template context . If you get lucky, your document has been cooked. It is available for download in the configured MEDIA_ROOT of the Django project Marion has been integrated to. You will find the link to the PDF document in the newly created document request (see the document_url field): { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : { \"fullname\" : \"John Doe\" , \"identifier\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" }, \"context_query\" : { \"fullname\" : \"John Doe\" }, \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" }","title":"Key concepts"},{"location":"#key_takeways","text":"Issuer : this keyword designates a particular type of document with its own templates and logic to fetch a context that will be used to create it. Document request : a database entry tracking the context (query) used to generate a document and its download link. Context query : parameters that will be used by an issuer to fetch a context that will be used to compile a document template. Context : all variables that will be used to render document templates ( e.g. a Django context).","title":"Key takeways"},{"location":"CHANGELOG/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 Added \u00b6 Distribute a complete documentation Fixed \u00b6 Add package description (README) 0.1.2 - 2021-04-06 \u00b6 Fixed \u00b6 Include templates and static files in distributed package 0.1.1 - 2021-04-06 \u00b6 Fixed \u00b6 Package name in version metadata 0.1.0 - 2021-03-26 \u00b6 Added \u00b6 Install security updates in project Docker images Add DocumentRequest model, serializer and API viewset Add DummyDocument example document issuer Implement document issuer pattern","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"Unreleased"},{"location":"CHANGELOG/#added","text":"Distribute a complete documentation","title":"Added"},{"location":"CHANGELOG/#fixed","text":"Add package description (README)","title":"Fixed"},{"location":"CHANGELOG/#012_-_2021-04-06","text":"","title":"0.1.2 - 2021-04-06"},{"location":"CHANGELOG/#fixed_1","text":"Include templates and static files in distributed package","title":"Fixed"},{"location":"CHANGELOG/#011_-_2021-04-06","text":"","title":"0.1.1 - 2021-04-06"},{"location":"CHANGELOG/#fixed_2","text":"Package name in version metadata","title":"Fixed"},{"location":"CHANGELOG/#010_-_2021-03-26","text":"","title":"0.1.0 - 2021-03-26"},{"location":"CHANGELOG/#added_1","text":"Install security updates in project Docker images Add DocumentRequest model, serializer and API viewset Add DummyDocument example document issuer Implement document issuer pattern","title":"Added"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2020-present GIP FUN MOOC. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"contribute/","text":"Contribute \u00b6 Getting started \u00b6 To start playing with Marion, you should build it using the bootstrap Make target: $ make bootstrap This will build a Docker image that will run Marion in a Django sandbox, start the postgresql docker compose service and run database migration. Once finished, you can start Django\u2019s development server using: $ make run The REST API development server should be up and running at: http://localhost:8000/api/documents/requests/ You can follow the web server logs using: $ make logs Lint your code \u00b6 To run python linters, use the lint Make target: $ make lint Linters can be run separately using the lint-{{ linter }} Make rule, e.g : $ make lint-pylint You can list all linters using: $ make help | grep lint- | sort If you need to run pylint with custom arguments, we provide an helper for this: $ bin/pylint Run tests \u00b6 Running tests with pytest can be achieved using: $ make test But we also provide an helper to add custom arguments to pytest calls ( e.g. calling a specific test pattern): $ bin/pytest -x -k test_foo_issuer Write documentation \u00b6 Documentation sources lie in the docs/ directory of the project. It is generated using MkDocs . We provide Make rules to use it: # Build the documentation $ make docs-build # Run the documentation development server $ make docs-serve Note that the documentation is automatically built by the CI platform we use, so you don\u2019t need to manually deploy it. Misc \u00b6 You will find the complete list of useful commands using: $ make help","title":"Contribute"},{"location":"contribute/#contribute","text":"","title":"Contribute"},{"location":"contribute/#getting_started","text":"To start playing with Marion, you should build it using the bootstrap Make target: $ make bootstrap This will build a Docker image that will run Marion in a Django sandbox, start the postgresql docker compose service and run database migration. Once finished, you can start Django\u2019s development server using: $ make run The REST API development server should be up and running at: http://localhost:8000/api/documents/requests/ You can follow the web server logs using: $ make logs","title":"Getting started"},{"location":"contribute/#lint_your_code","text":"To run python linters, use the lint Make target: $ make lint Linters can be run separately using the lint-{{ linter }} Make rule, e.g : $ make lint-pylint You can list all linters using: $ make help | grep lint- | sort If you need to run pylint with custom arguments, we provide an helper for this: $ bin/pylint","title":"Lint your code"},{"location":"contribute/#run_tests","text":"Running tests with pytest can be achieved using: $ make test But we also provide an helper to add custom arguments to pytest calls ( e.g. calling a specific test pattern): $ bin/pytest -x -k test_foo_issuer","title":"Run tests"},{"location":"contribute/#write_documentation","text":"Documentation sources lie in the docs/ directory of the project. It is generated using MkDocs . We provide Make rules to use it: # Build the documentation $ make docs-build # Run the documentation development server $ make docs-serve Note that the documentation is automatically built by the CI platform we use, so you don\u2019t need to manually deploy it.","title":"Write documentation"},{"location":"contribute/#misc","text":"You will find the complete list of useful commands using: $ make help","title":"Misc"},{"location":"install/","text":"Installation \u00b6 Pre-requisite \u00b6 Marion depends on the Weasyprint project . As such it inherits from its core dependencies. Please make sure that you have installed them before installing Marion. As example, in a Debian-based distribution, you may need to install the following packages: $ (sudo) apt-get install -y \\ libcairo2 \\ libffi-dev \\ libgdk-pixbuf2.0-0 \\ libpango-1.0-0 \\ libpangocairo-1.0-0 \\ shared-mime-info Install Marion python package \u00b6 Marion is distributed as a python package. It can be installed from PyPI using the pip tool (or any other python package manager): # Create a new virtualenv (optional) $ python -m venv venv $ source venv/bin/activate # Install the package (in a virtualenv) ( venv ) $ pip install django-marion From here, you have two options: either integrate the marion application in an existing Django project or create a new Django project to run Marion as a standalone service. Create a standalone sandbox for Marion \u00b6 If you already have a running Django project and intend to integrate Marion in this project, you can safely skip this section and read the next one. If you are starting from scratch to test Marion or prefer having a standalone service running marion, let\u2019s create a new Django project that will be used as a sandbox: # Install Django ( venv ) $ pip install Django # Create a new project ( venv ) $ django-admin startproject myproject You have created a new Django project called myproject . It should look like: myproject \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 myproject \u251c\u2500\u2500 asgi.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py 1 directory, 6 files You can now proceed with Marion\u2019s integration in the next subsection. Integrate Marion in a Django project \u00b6 Marion\u2019s integration in your project follows a standard procedure for a Django application: 1. add rest_framework and marion to your installed apps: # myproject/settings.py INSTALLED_APPS = [ \"django.contrib.admin\" , # [...] \"rest_framework\" , \"marion\" , ] 2. add marion urls to your ROOT_URLCONF module: # myproject/urls.py from django.conf import settings from django.conf.urls.static import static from django.contrib import admin from django.urls import include , path urlpatterns = ( [ path ( \"admin/\" , admin . site . urls ), # [...] path ( \"api/documents/\" , include ( \"marion.urls\" )), ] # Optionally serve static and media files when DEBUG=True + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) + static ( settings . STATIC_URL , document_root = settings . STATIC_ROOT ) ) 3. run marion \u2018s database migrations: ( venv ) $ python manage.py migrate Create your first document \u00b6 Now that Marion is configured and migrated, let\u2019s run Django\u2019s development server to generate a document: ( venv ) $ python manage.py runserver If you haven\u2019t installed http (come on, really?), you can safely test it in your virtual environment: ( venv ) $ pip install httpie Perform your first document request using http : ( venv ) $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' If everything has been properly configured, you should have a HTTP 200 response to this API request. And the json response should look like: { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : { \"fullname\" : \"John Doe\" , \"identifier\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" }, \"context_query\" : { \"fullname\" : \"John Doe\" }, \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" } As you may have already guessed, your document has been properly generated and it can be viewed/downloaded from the Django\u2019s media folder at the following URL: http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf At this stage, we have validated that Marion is properly installed and configured. Even if the dummy document looks nice, you may ask: \u201cOk, now what? How can I create custom documents that suit my needs?\u201d In the next section, answered this question will be.","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#pre-requisite","text":"Marion depends on the Weasyprint project . As such it inherits from its core dependencies. Please make sure that you have installed them before installing Marion. As example, in a Debian-based distribution, you may need to install the following packages: $ (sudo) apt-get install -y \\ libcairo2 \\ libffi-dev \\ libgdk-pixbuf2.0-0 \\ libpango-1.0-0 \\ libpangocairo-1.0-0 \\ shared-mime-info","title":"Pre-requisite"},{"location":"install/#install_marion_python_package","text":"Marion is distributed as a python package. It can be installed from PyPI using the pip tool (or any other python package manager): # Create a new virtualenv (optional) $ python -m venv venv $ source venv/bin/activate # Install the package (in a virtualenv) ( venv ) $ pip install django-marion From here, you have two options: either integrate the marion application in an existing Django project or create a new Django project to run Marion as a standalone service.","title":"Install Marion python package"},{"location":"install/#create_a_standalone_sandbox_for_marion","text":"If you already have a running Django project and intend to integrate Marion in this project, you can safely skip this section and read the next one. If you are starting from scratch to test Marion or prefer having a standalone service running marion, let\u2019s create a new Django project that will be used as a sandbox: # Install Django ( venv ) $ pip install Django # Create a new project ( venv ) $ django-admin startproject myproject You have created a new Django project called myproject . It should look like: myproject \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 myproject \u251c\u2500\u2500 asgi.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py 1 directory, 6 files You can now proceed with Marion\u2019s integration in the next subsection.","title":"Create a standalone sandbox for Marion"},{"location":"install/#integrate_marion_in_a_django_project","text":"Marion\u2019s integration in your project follows a standard procedure for a Django application: 1. add rest_framework and marion to your installed apps: # myproject/settings.py INSTALLED_APPS = [ \"django.contrib.admin\" , # [...] \"rest_framework\" , \"marion\" , ] 2. add marion urls to your ROOT_URLCONF module: # myproject/urls.py from django.conf import settings from django.conf.urls.static import static from django.contrib import admin from django.urls import include , path urlpatterns = ( [ path ( \"admin/\" , admin . site . urls ), # [...] path ( \"api/documents/\" , include ( \"marion.urls\" )), ] # Optionally serve static and media files when DEBUG=True + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) + static ( settings . STATIC_URL , document_root = settings . STATIC_ROOT ) ) 3. run marion \u2018s database migrations: ( venv ) $ python manage.py migrate","title":"Integrate Marion in a Django project"},{"location":"install/#create_your_first_document","text":"Now that Marion is configured and migrated, let\u2019s run Django\u2019s development server to generate a document: ( venv ) $ python manage.py runserver If you haven\u2019t installed http (come on, really?), you can safely test it in your virtual environment: ( venv ) $ pip install httpie Perform your first document request using http : ( venv ) $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' If everything has been properly configured, you should have a HTTP 200 response to this API request. And the json response should look like: { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : { \"fullname\" : \"John Doe\" , \"identifier\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" }, \"context_query\" : { \"fullname\" : \"John Doe\" }, \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" } As you may have already guessed, your document has been properly generated and it can be viewed/downloaded from the Django\u2019s media folder at the following URL: http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf At this stage, we have validated that Marion is properly installed and configured. Even if the dummy document looks nice, you may ask: \u201cOk, now what? How can I create custom documents that suit my needs?\u201d In the next section, answered this question will be.","title":"Create your first document"},{"location":"issuer/","text":"Create an issuer \u00b6 Once Marion is installed, you will need to create one issuer per document type you need to generate. Your issuers should stand in a python module that bundles templates and the business logic required to build your documents. This module can be distributed as a python package or a core Django application in your Django project. Module tree \u00b6 An example shop module tree follows: apps/shop \u251c\u2500\u2500 defaults.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 issuers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 invoice.py \u251c\u2500\u2500 static \u2502 \u2514\u2500\u2500 shop \u2502 \u2514\u2500\u2500 logo.svg \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 shop \u2502 \u251c\u2500\u2500 invoice.css \u2502 \u2514\u2500\u2500 invoice.html \u2514\u2500\u2500 tests \u2514\u2500\u2500 issuers \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_invoice.py As you may have noticed if you are familiar with Django: the module tree looks like a standard Django app (but without models, views and urls). Except for the static/{{ application_name }} directory, the project tree is only a recommendation, feel free to organize things the way you like. In the proposed project tree: defaults.py contains default values to configure your issuer, issuers module contains issuers (one file per issuer), static/{{ application_name }} is the place to store images that will be embedded in your rendered documents, templates/{{ application_name }} contains your HTML and CSS templates that will be used to generate your documents, and, tests/issuers directory will ship tests for your issuers (business logic). Business logic \u00b6 Now that your project tree is ready, you will need to write code for your Invoice issuer. Before writing code, we will have to explain a key concept in Marion\u2019s design: an issuer uses a context query to fetch a context that will be used to substitute variables in your templates. In other words, this context query is a collection of key-values that is required to build or fetch a collection of key-values that will serve as the context. An example issuer code follows (it will be commented in details later): # apps/shop/issuers/invoice.py import json from pathlib import Path from uuid import UUID import requests from pydantic import BaseModel from marion.issuers.base import AbstractDocument class Customer ( BaseModel ): \"\"\"Customer pydantic model\"\"\" name : str class Invoice ( BaseModel ): \"\"\"Invoice pydantic model\"\"\" invoice_id : UUID customer : Customer total : float class ContextModel ( BaseModel ): \"\"\"Context pydantic model\"\"\" invoice : Invoice class ContextQueryModel ( BaseModel ): \"\"\"Context query pydantic model\"\"\" order_id : UUID class Invoice ( AbstractDocument ): \"\"\"Invoice issuer\"\"\" keywords = [ \"MyShop\" , \"invoice\" ] context_model = ContextModel context_query_model = ContextQueryModel css_template_path = Path ( \"shop/invoice.css\" ) html_template_path = Path ( \"shop/invoice.html\" ) def fetch_context ( self ) -> dict : \"\"\"Write your business logic to fetch the context here\"\"\" response = requests . get ( f \"https://www.myshop.com/api/orders/ { self . context_query . order_id } \" ) order = json . loads ( response . json ()) return { \"invoice\" : { \"invoice_id\" : order . get ( \"id\" ), \"customer\" : { \"name\" : order . get ( \"customer\" ) . get ( \"fullname\" ), }, \"total\" : order . get ( \"total\" ), } } def get_title ( self ): \"\"\"Generate a PDF title that depends on the context\"\"\" return f \"Invoice ref. { self . context . invoice . invoice_id } \" After reading this simplified piece of code, you may have noticed that: your issuer class should inherit from the marion.issuers.base.AbstractDocument class, your issuer class should implement the fetch_context method, the fetch_context method should return a dictionnary of the context that will be used to render your templates (more on this later), you should define Pydantic models to validate data from your context and context query, Note that documents metadata such as the title , keywords or authors can be statically set as an issuer class attribute ( e.g. title ) or dynamically using the corresponding method ( e.g. get_title() for the title attribute in our example). For reference, see the marion.issuers.base.PDFFileMetadataMixin mixin implementation. Document templates \u00b6 While writing our issuer class, we\u2019ve taken care of the business logic to collect all required information (context variables) that will be integrated to the issuer document template. The second step is to implement the logical structure (HTML) and the design (CSS) of our document. While writing your document template, you must keep in mind that you are designing a printed document, e.g. writing CSS rules for the print media. You should also note that both your HTML and CSS files are Django templates that are consequently context-aware and versatile. Simplified example template files for the Invoice issuer are presented below. <!-- apps/shop/templates/shop/invoice.html --> {% load i18n %} {% load static %} < html > {% if debug %} < head > {{ css }} </ head > {% endif %} < body > < div class = \"invoice\" > < header > <!-- Company matters --> < div class = \"logo\" > < img src = \" {{ debug | yesno :\",file://\" }}{% static \"shop/logo.svg\" %} \" alt = \" {% trans \"company logo\" %} \" /> </ div > </ header > < article class = \"order\" > < div class = \"invoice-id\" > {% trans \"Invoice reference:\" %} {{ invoice.invoice_id }} </ div > < div class = \"customer\" > {{ invoice.customer.name }} </ div > < div class = \"total-amount\" > {{ invoice.total }} &euro; </ div > </ article > < footer > <!-- Contact informations --> </ footer > </ div > </ body > </ html > If you are familiar with Django templates, debug blocks usage or conditions can be confusing at first sight. We will explain those in the next subsection. /* apps/shop/templates/shop/invoice.css */ /* load extra fonts */ @ import url ( \"https://fonts.googleapis.com/css2?family=Open+Sans\" ) ; body { font-family : \"Open Sans\" , sans-serif ; font-size : 11 pt ; color : #222 ; } @ media print { /* ---------------------- * Reset margins for media * ---------------------- */ @ page { size : A4 landscape ; margin : 0 ; padding : 0 ; } body { padding : 0 ; background : #ffbe0b ; } * { margin : 0 ; padding : 0 ; } /* ---------------------- * Add custom styles below * ---------------------- */ . invoice { /* [...] */ } } Using the document template debug view \u00b6 Integrating a document template can be time consuming if you need to render it as a PDF every time you want to check how it looks like. To ease your life, we\u2019ve cooked a template debug view that can be activated in your development environment by modifiying your root URLs configuration as follow: # myproject.myproject.urls from django.conf import settings # [...] if settings . DEBUG : urlpatterns += [ path ( \"__debug__/\" , include ( \"marion.urls.debug\" ))] We advice you not to activate this in production, it should only be active for development. By using this view, you will be able to \u201csee\u201d your document in your browser as a normal web page at the following URL: http://localhost:8000/ debug /templates/ Two GET request parameters are required to point to your template: issuer : the target issuer path context : the issuer context (as resulting from the issuer\u2019s fetch_context method) A complete debug template URL example may look like: http://localhost:8000/__debug__/templates/?issuer=apps.shop.issuers.invoice.Invoice&context=%7B%22invoice%22%3A+%7B%22invoice-id%22%3A+%22d972fef9%22%7D Note that the JSON-serialized context should be URL encoded. This can be achieved using the following python snippet: import json import urllib.parse with open ( \"context.json\" ) as example : print ( urllib . parse . quote_plus ( json . dumps ( json . load ( example ) ) ) ) As mentionned earlier, you should keep in mind that the media that will be used to render your document is a printer, so you should enable print media emulation in the developer tools of your web browser to have a better idea of what it will look like once rendered as a PDF. In expected conditions (outside from a Django view context), Marion generates a PDF file using separated HTML and CSS content. Linked files ( e.g. embedded images) are expected to be referenced using the file:// protocol (a custom url fetcher will integrate those files in the final document). But, when using this debug view, we need to inject CSS styles in the template and serve static files by Django to display them in the browser. This is why we add a debug variable to the Django context. This variable should be used to add CSS content in the debug view: < html > {% if debug %} < head > {{ css }} </ head > {% endif %} <!-- [...] --> </ html > And display images: < img src = \" {{ debug | yesno :\",file://\" }}{% static \"shop/logo.svg\" %} \" alt = \" {% trans \"company logo\" %} \" /> Issuer configuration \u00b6 Once written, we should declare distributed application issuers: # apps/shop/defaults.py from django.db.models import TextChoices from django.utils.translation import gettext_lazy as _ class ShopDocumentIssuerChoices ( TextChoices ): \"\"\"List active document issuers.\"\"\" INVOICE = \"apps.shop.issuers.invoice.Invoice\" , _ ( \"Invoice\" ) And activate them in our Django settings: # pyproject/myproject/settings.py # Add the shop app INSTALLED_APPS = [ \"django.contrib.admin\" , # [...] \"rest_framework\" , \"marion\" , \"apps.shop\" , ] # Activate shop issuers MARION_DOCUMENT_ISSUER_CHOICES_CLASS = \"apps.shop.defaults.ShopDocumentIssuerChoices\" Only issuers listed in the ShopDocumentIssuerChoices can be used in the current Django project. If you need more issuers, you should declare them in the ShopDocumentIssuerChoices enum-like object or declare a new enum listing all allowed issuers for your project. Note that modifying this setting requires to create a new database migration as this will change choices of the DocumentRequest.issuer field. Document rendering \u00b6 Once your issuer has been implemented and activated, you can generate the corresponding PDF file using either the issuer API, the DocumentRequest model or the REST API endpoint. In the first scenario, the generation of your document will not be tracked as a document request in your database. Using the issuer API \u00b6 To generate a document, you will need to instantiate the corresponding issuer with an appropriate context query, and then call the create() method: from apps.shop.issuers.invoice.Invoice invoice = Invoice ( context_query = { \"order_id\" : \"7866454a-600e-434a-a546-04a286b208db\" } ) # Generate the PDF file invoice . create () Your document should have been rendered in a PDF file created in the MARION_DOCUMENTS_ROOT setting path. For reference, see the marion.issuers.base.AbstractDocument class. Using the DocumentRequest Django model \u00b6 If you want to track documents creation in your database, you should use Marion\u2019s DocumentRequest model in your views: # apps/shop/views.py from marion.models import DocumentRequest def payment ( request ): \"\"\"Payment view\"\"\" order_id = request . POST . get ( \"order_id\" ) invoice = DocumentRequest . objects . create ( issuer = \"apps.shop.issuers.invoice.Invoice\" , context_query = { \"order_id\" : order_id } ) # [...] Your document should have been rendered in a PDF file created in the MARION_DOCUMENTS_ROOT setting path. For reference, see the marion.models.DocumentRequest class and the marion.issuers.base.AbstractDocument class. Using the REST API \u00b6 If you have configured Marion\u2019s urls in your project, you can use the document request view set to get, list or create a new document: # Create a new document using the invoice issuer $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"apps.shop.issuers.invoice.Invoice\" \\ context_query = '{\"order_id\": \"7866454a-600e-434a-a546-04a286b208db\"}' You should have a HTTP 200 OK response. Yatta! Once created, check the document request ID (and the corresponding document) by listing created objects via : $ http GET http://localhost:8000/api/documents/requests/ Issuer testing \u00b6 Don\u2019t forget to test your business logic implemented in the fetch_context method of your issuer. We use pytest along with hypothesis as it has builtin support for Pydantic models.","title":"Create an issuer"},{"location":"issuer/#create_an_issuer","text":"Once Marion is installed, you will need to create one issuer per document type you need to generate. Your issuers should stand in a python module that bundles templates and the business logic required to build your documents. This module can be distributed as a python package or a core Django application in your Django project.","title":"Create an issuer"},{"location":"issuer/#module_tree","text":"An example shop module tree follows: apps/shop \u251c\u2500\u2500 defaults.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 issuers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 invoice.py \u251c\u2500\u2500 static \u2502 \u2514\u2500\u2500 shop \u2502 \u2514\u2500\u2500 logo.svg \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 shop \u2502 \u251c\u2500\u2500 invoice.css \u2502 \u2514\u2500\u2500 invoice.html \u2514\u2500\u2500 tests \u2514\u2500\u2500 issuers \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_invoice.py As you may have noticed if you are familiar with Django: the module tree looks like a standard Django app (but without models, views and urls). Except for the static/{{ application_name }} directory, the project tree is only a recommendation, feel free to organize things the way you like. In the proposed project tree: defaults.py contains default values to configure your issuer, issuers module contains issuers (one file per issuer), static/{{ application_name }} is the place to store images that will be embedded in your rendered documents, templates/{{ application_name }} contains your HTML and CSS templates that will be used to generate your documents, and, tests/issuers directory will ship tests for your issuers (business logic).","title":"Module tree"},{"location":"issuer/#business_logic","text":"Now that your project tree is ready, you will need to write code for your Invoice issuer. Before writing code, we will have to explain a key concept in Marion\u2019s design: an issuer uses a context query to fetch a context that will be used to substitute variables in your templates. In other words, this context query is a collection of key-values that is required to build or fetch a collection of key-values that will serve as the context. An example issuer code follows (it will be commented in details later): # apps/shop/issuers/invoice.py import json from pathlib import Path from uuid import UUID import requests from pydantic import BaseModel from marion.issuers.base import AbstractDocument class Customer ( BaseModel ): \"\"\"Customer pydantic model\"\"\" name : str class Invoice ( BaseModel ): \"\"\"Invoice pydantic model\"\"\" invoice_id : UUID customer : Customer total : float class ContextModel ( BaseModel ): \"\"\"Context pydantic model\"\"\" invoice : Invoice class ContextQueryModel ( BaseModel ): \"\"\"Context query pydantic model\"\"\" order_id : UUID class Invoice ( AbstractDocument ): \"\"\"Invoice issuer\"\"\" keywords = [ \"MyShop\" , \"invoice\" ] context_model = ContextModel context_query_model = ContextQueryModel css_template_path = Path ( \"shop/invoice.css\" ) html_template_path = Path ( \"shop/invoice.html\" ) def fetch_context ( self ) -> dict : \"\"\"Write your business logic to fetch the context here\"\"\" response = requests . get ( f \"https://www.myshop.com/api/orders/ { self . context_query . order_id } \" ) order = json . loads ( response . json ()) return { \"invoice\" : { \"invoice_id\" : order . get ( \"id\" ), \"customer\" : { \"name\" : order . get ( \"customer\" ) . get ( \"fullname\" ), }, \"total\" : order . get ( \"total\" ), } } def get_title ( self ): \"\"\"Generate a PDF title that depends on the context\"\"\" return f \"Invoice ref. { self . context . invoice . invoice_id } \" After reading this simplified piece of code, you may have noticed that: your issuer class should inherit from the marion.issuers.base.AbstractDocument class, your issuer class should implement the fetch_context method, the fetch_context method should return a dictionnary of the context that will be used to render your templates (more on this later), you should define Pydantic models to validate data from your context and context query, Note that documents metadata such as the title , keywords or authors can be statically set as an issuer class attribute ( e.g. title ) or dynamically using the corresponding method ( e.g. get_title() for the title attribute in our example). For reference, see the marion.issuers.base.PDFFileMetadataMixin mixin implementation.","title":"Business logic"},{"location":"issuer/#document_templates","text":"While writing our issuer class, we\u2019ve taken care of the business logic to collect all required information (context variables) that will be integrated to the issuer document template. The second step is to implement the logical structure (HTML) and the design (CSS) of our document. While writing your document template, you must keep in mind that you are designing a printed document, e.g. writing CSS rules for the print media. You should also note that both your HTML and CSS files are Django templates that are consequently context-aware and versatile. Simplified example template files for the Invoice issuer are presented below. <!-- apps/shop/templates/shop/invoice.html --> {% load i18n %} {% load static %} < html > {% if debug %} < head > {{ css }} </ head > {% endif %} < body > < div class = \"invoice\" > < header > <!-- Company matters --> < div class = \"logo\" > < img src = \" {{ debug | yesno :\",file://\" }}{% static \"shop/logo.svg\" %} \" alt = \" {% trans \"company logo\" %} \" /> </ div > </ header > < article class = \"order\" > < div class = \"invoice-id\" > {% trans \"Invoice reference:\" %} {{ invoice.invoice_id }} </ div > < div class = \"customer\" > {{ invoice.customer.name }} </ div > < div class = \"total-amount\" > {{ invoice.total }} &euro; </ div > </ article > < footer > <!-- Contact informations --> </ footer > </ div > </ body > </ html > If you are familiar with Django templates, debug blocks usage or conditions can be confusing at first sight. We will explain those in the next subsection. /* apps/shop/templates/shop/invoice.css */ /* load extra fonts */ @ import url ( \"https://fonts.googleapis.com/css2?family=Open+Sans\" ) ; body { font-family : \"Open Sans\" , sans-serif ; font-size : 11 pt ; color : #222 ; } @ media print { /* ---------------------- * Reset margins for media * ---------------------- */ @ page { size : A4 landscape ; margin : 0 ; padding : 0 ; } body { padding : 0 ; background : #ffbe0b ; } * { margin : 0 ; padding : 0 ; } /* ---------------------- * Add custom styles below * ---------------------- */ . invoice { /* [...] */ } }","title":"Document templates"},{"location":"issuer/#using_the_document_template_debug_view","text":"Integrating a document template can be time consuming if you need to render it as a PDF every time you want to check how it looks like. To ease your life, we\u2019ve cooked a template debug view that can be activated in your development environment by modifiying your root URLs configuration as follow: # myproject.myproject.urls from django.conf import settings # [...] if settings . DEBUG : urlpatterns += [ path ( \"__debug__/\" , include ( \"marion.urls.debug\" ))] We advice you not to activate this in production, it should only be active for development. By using this view, you will be able to \u201csee\u201d your document in your browser as a normal web page at the following URL: http://localhost:8000/ debug /templates/ Two GET request parameters are required to point to your template: issuer : the target issuer path context : the issuer context (as resulting from the issuer\u2019s fetch_context method) A complete debug template URL example may look like: http://localhost:8000/__debug__/templates/?issuer=apps.shop.issuers.invoice.Invoice&context=%7B%22invoice%22%3A+%7B%22invoice-id%22%3A+%22d972fef9%22%7D Note that the JSON-serialized context should be URL encoded. This can be achieved using the following python snippet: import json import urllib.parse with open ( \"context.json\" ) as example : print ( urllib . parse . quote_plus ( json . dumps ( json . load ( example ) ) ) ) As mentionned earlier, you should keep in mind that the media that will be used to render your document is a printer, so you should enable print media emulation in the developer tools of your web browser to have a better idea of what it will look like once rendered as a PDF. In expected conditions (outside from a Django view context), Marion generates a PDF file using separated HTML and CSS content. Linked files ( e.g. embedded images) are expected to be referenced using the file:// protocol (a custom url fetcher will integrate those files in the final document). But, when using this debug view, we need to inject CSS styles in the template and serve static files by Django to display them in the browser. This is why we add a debug variable to the Django context. This variable should be used to add CSS content in the debug view: < html > {% if debug %} < head > {{ css }} </ head > {% endif %} <!-- [...] --> </ html > And display images: < img src = \" {{ debug | yesno :\",file://\" }}{% static \"shop/logo.svg\" %} \" alt = \" {% trans \"company logo\" %} \" />","title":"Using the document template debug view"},{"location":"issuer/#issuer_configuration","text":"Once written, we should declare distributed application issuers: # apps/shop/defaults.py from django.db.models import TextChoices from django.utils.translation import gettext_lazy as _ class ShopDocumentIssuerChoices ( TextChoices ): \"\"\"List active document issuers.\"\"\" INVOICE = \"apps.shop.issuers.invoice.Invoice\" , _ ( \"Invoice\" ) And activate them in our Django settings: # pyproject/myproject/settings.py # Add the shop app INSTALLED_APPS = [ \"django.contrib.admin\" , # [...] \"rest_framework\" , \"marion\" , \"apps.shop\" , ] # Activate shop issuers MARION_DOCUMENT_ISSUER_CHOICES_CLASS = \"apps.shop.defaults.ShopDocumentIssuerChoices\" Only issuers listed in the ShopDocumentIssuerChoices can be used in the current Django project. If you need more issuers, you should declare them in the ShopDocumentIssuerChoices enum-like object or declare a new enum listing all allowed issuers for your project. Note that modifying this setting requires to create a new database migration as this will change choices of the DocumentRequest.issuer field.","title":"Issuer configuration"},{"location":"issuer/#document_rendering","text":"Once your issuer has been implemented and activated, you can generate the corresponding PDF file using either the issuer API, the DocumentRequest model or the REST API endpoint. In the first scenario, the generation of your document will not be tracked as a document request in your database.","title":"Document rendering"},{"location":"issuer/#using_the_issuer_api","text":"To generate a document, you will need to instantiate the corresponding issuer with an appropriate context query, and then call the create() method: from apps.shop.issuers.invoice.Invoice invoice = Invoice ( context_query = { \"order_id\" : \"7866454a-600e-434a-a546-04a286b208db\" } ) # Generate the PDF file invoice . create () Your document should have been rendered in a PDF file created in the MARION_DOCUMENTS_ROOT setting path. For reference, see the marion.issuers.base.AbstractDocument class.","title":"Using the issuer API"},{"location":"issuer/#using_the_documentrequest_django_model","text":"If you want to track documents creation in your database, you should use Marion\u2019s DocumentRequest model in your views: # apps/shop/views.py from marion.models import DocumentRequest def payment ( request ): \"\"\"Payment view\"\"\" order_id = request . POST . get ( \"order_id\" ) invoice = DocumentRequest . objects . create ( issuer = \"apps.shop.issuers.invoice.Invoice\" , context_query = { \"order_id\" : order_id } ) # [...] Your document should have been rendered in a PDF file created in the MARION_DOCUMENTS_ROOT setting path. For reference, see the marion.models.DocumentRequest class and the marion.issuers.base.AbstractDocument class.","title":"Using the DocumentRequest Django model"},{"location":"issuer/#using_the_rest_api","text":"If you have configured Marion\u2019s urls in your project, you can use the document request view set to get, list or create a new document: # Create a new document using the invoice issuer $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"apps.shop.issuers.invoice.Invoice\" \\ context_query = '{\"order_id\": \"7866454a-600e-434a-a546-04a286b208db\"}' You should have a HTTP 200 OK response. Yatta! Once created, check the document request ID (and the corresponding document) by listing created objects via : $ http GET http://localhost:8000/api/documents/requests/","title":"Using the REST API"},{"location":"issuer/#issuer_testing","text":"Don\u2019t forget to test your business logic implemented in the fetch_context method of your issuer. We use pytest along with hypothesis as it has builtin support for Pydantic models.","title":"Issuer testing"},{"location":"settings/","text":"Settings \u00b6 Marion\u2019s defaults can be overridden using the following Django settings: MARION_DOCUMENT_ISSUER_CHOICES_CLASS : the list of avaiable active issuers for your project (default: marion.defaults.DocumentIssuerChoices ) MARION_DOCUMENTS_ROOT : the root directory that will store generated documents (default: Path(settings.MEDIA_ROOT) ) MARION_DOCUMENTS_TEMPLATE_ROOT : the default relative template path where to find templates for your issuer (default: Path(\"marion\") )","title":"Settings"},{"location":"settings/#settings","text":"Marion\u2019s defaults can be overridden using the following Django settings: MARION_DOCUMENT_ISSUER_CHOICES_CLASS : the list of avaiable active issuers for your project (default: marion.defaults.DocumentIssuerChoices ) MARION_DOCUMENTS_ROOT : the root directory that will store generated documents (default: Path(settings.MEDIA_ROOT) ) MARION_DOCUMENTS_TEMPLATE_ROOT : the default relative template path where to find templates for your issuer (default: Path(\"marion\") )","title":"Settings"},{"location":"sources/issuer/","text":"Issuer \u00b6 TODO: include base issuer source code here.","title":"Issuer"},{"location":"sources/issuer/#issuer","text":"TODO: include base issuer source code here.","title":"Issuer"},{"location":"sources/model/","text":"Model \u00b6 TODO: include source code here.","title":"Model"},{"location":"sources/model/#model","text":"TODO: include source code here.","title":"Model"}]}
{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Marion is a documents factory backend to generate PDF files using a REST API and HTML/CSS templates. Key concepts \u00b6 Marion is a Django application that can be integrated to your Django project or deployed to production as a standalone service. To generate PDF files with styles, first, you will have to write your own document issuer and related HTML/CSS templates in a Django application package. Once your issuer has been installed and configured, you can create a document request using the backend API with your favorite HTTP client (we \u2764\ufe0f http , but curl is perfectly fine \ud83d\ude09): # Create a new document using the dummy issuer $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' As you may have noticed, you should provide two parameters for this request: the document issuer for this request (as a python module path), and, a context_query that will be used by the issuer to resolve the context that will be injected in your HTML/CSS templates to generate a document; think of a context as a Django template context . If you get lucky, your document has been cooked and is available for download in the configured MEDIA_ROOT of the Django project Marion has been integrated to. You will find the link to the PDF document in the newly created document request (see the document_url field): { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : \"{\\\"fullname\\\": \\\"John Doe\\\", \\\"identifier\\\": \\\"60593260-2c0f-4c54-88e5-96ae0db06081\\\"}\" , \"context_query\" : \"{\\\"fullname\\\": \\\"John Doe\\\"}\" , \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" } Key takeways \u00b6 Issuer : we use this keyword to designate a particular type of document with its own templates and logic to fetch a context that will be used to create it. Document request : a database entry tracking the context (query) used to generate a document and its download link. Context query : parameters that will used by an issuer to fetch a context that will be used to compile a document template. Context : all variables that will be used to render document templates ( e.g. a Django context).","title":"Introduction"},{"location":"#introduction","text":"Marion is a documents factory backend to generate PDF files using a REST API and HTML/CSS templates.","title":"Introduction"},{"location":"#key_concepts","text":"Marion is a Django application that can be integrated to your Django project or deployed to production as a standalone service. To generate PDF files with styles, first, you will have to write your own document issuer and related HTML/CSS templates in a Django application package. Once your issuer has been installed and configured, you can create a document request using the backend API with your favorite HTTP client (we \u2764\ufe0f http , but curl is perfectly fine \ud83d\ude09): # Create a new document using the dummy issuer $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' As you may have noticed, you should provide two parameters for this request: the document issuer for this request (as a python module path), and, a context_query that will be used by the issuer to resolve the context that will be injected in your HTML/CSS templates to generate a document; think of a context as a Django template context . If you get lucky, your document has been cooked and is available for download in the configured MEDIA_ROOT of the Django project Marion has been integrated to. You will find the link to the PDF document in the newly created document request (see the document_url field): { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : \"{\\\"fullname\\\": \\\"John Doe\\\", \\\"identifier\\\": \\\"60593260-2c0f-4c54-88e5-96ae0db06081\\\"}\" , \"context_query\" : \"{\\\"fullname\\\": \\\"John Doe\\\"}\" , \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" }","title":"Key concepts"},{"location":"#key_takeways","text":"Issuer : we use this keyword to designate a particular type of document with its own templates and logic to fetch a context that will be used to create it. Document request : a database entry tracking the context (query) used to generate a document and its download link. Context query : parameters that will used by an issuer to fetch a context that will be used to compile a document template. Context : all variables that will be used to render document templates ( e.g. a Django context).","title":"Key takeways"},{"location":"CHANGELOG/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 0.1.0 - 2021-03-26 \u00b6 Added \u00b6 Add DocumentRequest model, serializer and API viewset Add DummyDocument example document issuer Implement document issuer pattern","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"Unreleased"},{"location":"CHANGELOG/#010_-_2021-03-26","text":"","title":"0.1.0 - 2021-03-26"},{"location":"CHANGELOG/#added","text":"Add DocumentRequest model, serializer and API viewset Add DummyDocument example document issuer Implement document issuer pattern","title":"Added"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2020-present GIP FUN MOOC. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"contribute/","text":"","title":"Contribute"},{"location":"install/","text":"Installation \u00b6 Marion is distributed as a python package. It can be installed from PyPI using the pip tool (or any other python package manager): # Create a new virtualenv (optional) $ python -m venv venv $ source venv/bin/activate # Install the package (in a virtualenv) ( venv ) $ pip install marion From here, you have two options: either integrate the marion application in an existing Django project or create a new Django project to run Marion as a standalone service. Create a standalone sandbox for Marion \u00b6 If you already have a running Django project and intend to integrate Marion in this project, you can safely skip this section and read the next one. If you are starting from scratch to test Marion or prefer having a standalone service running marion, let\u2019s create a new Django project that will be used as a sandbox: # Install Django ( venv ) $ pip install Django # Create a new project ( venv ) $ django-admin startproject myproject Congratulations! You have created a new Django project called myproject . It should look like: myproject \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 myproject \u251c\u2500\u2500 asgi.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py 1 directory, 6 files You can now proceed with Marion\u2019s integration in the next subsection. Integrate Marion in a Django project \u00b6 Marion\u2019s integration in your project follows a standard procedure for a Django application: add rest_framework and marion to your installed apps: # myproject/settings.py INSTALLED_APPS = [ \"django.contrib.admin\" , # [...] \"rest_framework\" , \"marion\" , ] add marion urls to your ROOT_URLCONF module: # myproject/urls.py urlpatterns = ( [ path ( \"admin/\" , admin . site . urls ), # [...] path ( \"api/documents/\" , include ( \"marion.urls\" )), ] ) run marion \u2018s database migrations: ( venv ) $ python manage.py migrate Create your first document \u00b6 Now that Marion is configured and migrated, we will run Django\u2019s development server to generate our very first document: ( venv ) $ python manage.py runserver If you haven\u2019t installed http (come on, really?), you can safely test it in your virtual environment: ( venv ) $ pip install httpie Perform your first document request using http : ( venv ) $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' If everything has been properly configured, you should have a HTTP 200 response to this API request. And the json response should look like: { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : \"{\\\"fullname\\\": \\\"John Doe\\\", \\\"identifier\\\": \\\"60593260-2c0f-4c54-88e5-96ae0db06081\\\"}\" , \"context_query\" : \"{\\\"fullname\\\": \\\"John Doe\\\"}\" , \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" } As you may have already guessed, your document has been properly generated and it can be viewed/downloaded from the Django\u2019s media folder at the following URL: http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf At this stage, we have validated that Marion is properly installed and configured. Even if the dummy document looks nice, you may ask: \u201cOk, now what? How can I create custom documents that suit my needs?\u201d In the next section, answered this question will be.","title":"Installation"},{"location":"install/#installation","text":"Marion is distributed as a python package. It can be installed from PyPI using the pip tool (or any other python package manager): # Create a new virtualenv (optional) $ python -m venv venv $ source venv/bin/activate # Install the package (in a virtualenv) ( venv ) $ pip install marion From here, you have two options: either integrate the marion application in an existing Django project or create a new Django project to run Marion as a standalone service.","title":"Installation"},{"location":"install/#create_a_standalone_sandbox_for_marion","text":"If you already have a running Django project and intend to integrate Marion in this project, you can safely skip this section and read the next one. If you are starting from scratch to test Marion or prefer having a standalone service running marion, let\u2019s create a new Django project that will be used as a sandbox: # Install Django ( venv ) $ pip install Django # Create a new project ( venv ) $ django-admin startproject myproject Congratulations! You have created a new Django project called myproject . It should look like: myproject \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 myproject \u251c\u2500\u2500 asgi.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings.py \u251c\u2500\u2500 urls.py \u2514\u2500\u2500 wsgi.py 1 directory, 6 files You can now proceed with Marion\u2019s integration in the next subsection.","title":"Create a standalone sandbox for Marion"},{"location":"install/#integrate_marion_in_a_django_project","text":"Marion\u2019s integration in your project follows a standard procedure for a Django application: add rest_framework and marion to your installed apps: # myproject/settings.py INSTALLED_APPS = [ \"django.contrib.admin\" , # [...] \"rest_framework\" , \"marion\" , ] add marion urls to your ROOT_URLCONF module: # myproject/urls.py urlpatterns = ( [ path ( \"admin/\" , admin . site . urls ), # [...] path ( \"api/documents/\" , include ( \"marion.urls\" )), ] ) run marion \u2018s database migrations: ( venv ) $ python manage.py migrate","title":"Integrate Marion in a Django project"},{"location":"install/#create_your_first_document","text":"Now that Marion is configured and migrated, we will run Django\u2019s development server to generate our very first document: ( venv ) $ python manage.py runserver If you haven\u2019t installed http (come on, really?), you can safely test it in your virtual environment: ( venv ) $ pip install httpie Perform your first document request using http : ( venv ) $ http POST http://localhost:8000/api/documents/requests/ \\ issuer = \"marion.certificates.issuers.DummyDocument\" \\ context_query = '{\"fullname\": \"John Doe\"}' If everything has been properly configured, you should have a HTTP 200 response to this API request. And the json response should look like: { \"document_id\" : \"60593260-2c0f-4c54-88e5-96ae0db06081\" , \"document_url\" : \"http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf\" , \"context\" : \"{\\\"fullname\\\": \\\"John Doe\\\", \\\"identifier\\\": \\\"60593260-2c0f-4c54-88e5-96ae0db06081\\\"}\" , \"context_query\" : \"{\\\"fullname\\\": \\\"John Doe\\\"}\" , \"created_on\" : \"2021-03-12T15:48:15.737311Z\" , \"issuer\" : \"marion.documents.issuers.DummyDocument\" , \"updated_on\" : \"2021-03-12T15:48:15.737336Z\" , \"url\" : \"http://localhost:8000/api/documents/requests/b90031a6-dcb4-49d6-ac6c-017030352f33/\" } As you may have already guessed, your document has been properly generated and it can be viewed/downloaded from the Django\u2019s media folder at the following URL: http://localhost:8000/media/60593260-2c0f-4c54-88e5-96ae0db06081.pdf At this stage, we have validated that Marion is properly installed and configured. Even if the dummy document looks nice, you may ask: \u201cOk, now what? How can I create custom documents that suit my needs?\u201d In the next section, answered this question will be.","title":"Create your first document"},{"location":"issuer-reference/","text":"Issuer reference \u00b6 TODO: include base issuer source code here.","title":"Issuer reference"},{"location":"issuer-reference/#issuer_reference","text":"TODO: include base issuer source code here.","title":"Issuer reference"},{"location":"issuer/","text":"Create an issuer \u00b6 Once Marion is installed, you will need to create an issuer . An issuer is a python module that bundles templates and the business logic required to build your documents. This module can be distributed as a python package or a core Django application in your Django project. Issuer module tree \u00b6 An example shop module tree follows: apps/shop \u251c\u2500\u2500 defaults.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 issuers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 invoice.py \u251c\u2500\u2500 static \u2502 \u2514\u2500\u2500 shop \u2502 \u2514\u2500\u2500 logo.svg \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 shop \u2502 \u251c\u2500\u2500 invoice.css \u2502 \u2514\u2500\u2500 invoice.html \u2514\u2500\u2500 tests \u2514\u2500\u2500 issuers \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_invoice.py As you may have noticed if you are familiar with Django: the module tree looks like a standard Django apps (but without models, views and urls). Except for the static/{{ application_name }} directory, the project tree is only a recommendation, feel free to organize things the way you like. In the proposed project tree: defaults.py contains default values to configure your issuer, issuers module contains issuers (one file per issuer), static/{{ application_name }} is the place to store images that will be embedded in your rendered documents, templates/{{ application_name }} contains your HTML and CSS templates that will be used to generate your documents, and, tests/issuers directory will ship tests for your issuers (business logic). Write an issuer \u00b6 Now that your project tree is ready, you will need to write code for your Invoice issuer. Before writing code, we will have to explain a key concept in Marion\u2019s design: an issuer uses a context query to fetch a context that will used to substitute variables in your templates. In other words, this context query is a collection of key-values that is required to build or fetch a collection of key-values that will serve as the context. An example issuer code follows (it will be commented in details later): # apps/shop/issuers/invoice.py import json from pathlib import Path from uuid import UUID import requests from pydantic import BaseModel from marion.issuers.base import AbstractDocument class Customer ( BaseModel ): \"\"\"Customer pydantic model\"\"\" name : str class Invoice ( BaseModel ): \"\"\"Invoice pydantic model\"\"\" invoice_id : UUID customer : Customer total : float class ContextModel ( BaseModel ): \"\"\"Context pydantic model\"\"\" invoice : Invoice class ContextQueryModel ( BaseModel ): \"\"\"Context query pydantic model\"\"\" order_id : UUID class Invoice ( AbstractDocument ): \"\"\"Invoice issuer\"\"\" keywords = [ \"MyShop\" , \"invoice\" ] context_model = ContextModel context_query_model = ContextQueryModel css_template_path = Path ( \"shop/invoice.css\" ) html_template_path = Path ( \"shop/invoice.html\" ) def fetch_context ( self ) -> dict : \"\"\"Write your business logic to fetch the context here\"\"\" response = requests . get ( f \"https://www.myshop.com/api/orders/ { self . context_query . order_id } \" ) order = json . loads ( response . json ()) return { \"invoice\" : { \"invoice_id\" : order . get ( \"id\" ), \"customer\" : { \"name\" : order . get ( \"customer\" ) . get ( \"fullname\" ) } \"total\" : order . get ( \"total\" ) } } def get_title ( self ): \"\"\"Generate a PDF title that depends on the context\"\"\" return f \"Invoice ref. { self . context . invoice . invoice_id } \" After reading this simplified piece of code, you may have noticed that: your issuer class should inherit from the marion.issuers.base.AbstractDocument class, your issuer class should implement the fetch_context method, the fetch_context method should return a dictionnary of the context that will be used to render your templates (more on this later), you should define Pydantic models to validate data from your context and context query, Note that documents metadata such as the title , keywords or authors can be statically set as an issuer class attribute ( e.g. title ) or dynamically using the corresponding method ( e.g. get_title() for the title attribute in our example).","title":"Create an issuer"},{"location":"issuer/#create_an_issuer","text":"Once Marion is installed, you will need to create an issuer . An issuer is a python module that bundles templates and the business logic required to build your documents. This module can be distributed as a python package or a core Django application in your Django project.","title":"Create an issuer"},{"location":"issuer/#issuer_module_tree","text":"An example shop module tree follows: apps/shop \u251c\u2500\u2500 defaults.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 issuers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 invoice.py \u251c\u2500\u2500 static \u2502 \u2514\u2500\u2500 shop \u2502 \u2514\u2500\u2500 logo.svg \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 shop \u2502 \u251c\u2500\u2500 invoice.css \u2502 \u2514\u2500\u2500 invoice.html \u2514\u2500\u2500 tests \u2514\u2500\u2500 issuers \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_invoice.py As you may have noticed if you are familiar with Django: the module tree looks like a standard Django apps (but without models, views and urls). Except for the static/{{ application_name }} directory, the project tree is only a recommendation, feel free to organize things the way you like. In the proposed project tree: defaults.py contains default values to configure your issuer, issuers module contains issuers (one file per issuer), static/{{ application_name }} is the place to store images that will be embedded in your rendered documents, templates/{{ application_name }} contains your HTML and CSS templates that will be used to generate your documents, and, tests/issuers directory will ship tests for your issuers (business logic).","title":"Issuer module tree"},{"location":"issuer/#write_an_issuer","text":"Now that your project tree is ready, you will need to write code for your Invoice issuer. Before writing code, we will have to explain a key concept in Marion\u2019s design: an issuer uses a context query to fetch a context that will used to substitute variables in your templates. In other words, this context query is a collection of key-values that is required to build or fetch a collection of key-values that will serve as the context. An example issuer code follows (it will be commented in details later): # apps/shop/issuers/invoice.py import json from pathlib import Path from uuid import UUID import requests from pydantic import BaseModel from marion.issuers.base import AbstractDocument class Customer ( BaseModel ): \"\"\"Customer pydantic model\"\"\" name : str class Invoice ( BaseModel ): \"\"\"Invoice pydantic model\"\"\" invoice_id : UUID customer : Customer total : float class ContextModel ( BaseModel ): \"\"\"Context pydantic model\"\"\" invoice : Invoice class ContextQueryModel ( BaseModel ): \"\"\"Context query pydantic model\"\"\" order_id : UUID class Invoice ( AbstractDocument ): \"\"\"Invoice issuer\"\"\" keywords = [ \"MyShop\" , \"invoice\" ] context_model = ContextModel context_query_model = ContextQueryModel css_template_path = Path ( \"shop/invoice.css\" ) html_template_path = Path ( \"shop/invoice.html\" ) def fetch_context ( self ) -> dict : \"\"\"Write your business logic to fetch the context here\"\"\" response = requests . get ( f \"https://www.myshop.com/api/orders/ { self . context_query . order_id } \" ) order = json . loads ( response . json ()) return { \"invoice\" : { \"invoice_id\" : order . get ( \"id\" ), \"customer\" : { \"name\" : order . get ( \"customer\" ) . get ( \"fullname\" ) } \"total\" : order . get ( \"total\" ) } } def get_title ( self ): \"\"\"Generate a PDF title that depends on the context\"\"\" return f \"Invoice ref. { self . context . invoice . invoice_id } \" After reading this simplified piece of code, you may have noticed that: your issuer class should inherit from the marion.issuers.base.AbstractDocument class, your issuer class should implement the fetch_context method, the fetch_context method should return a dictionnary of the context that will be used to render your templates (more on this later), you should define Pydantic models to validate data from your context and context query, Note that documents metadata such as the title , keywords or authors can be statically set as an issuer class attribute ( e.g. title ) or dynamically using the corresponding method ( e.g. get_title() for the title attribute in our example).","title":"Write an issuer"}]}